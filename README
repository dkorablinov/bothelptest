## Задача

Есть веб-api, принимающее события для группы аккаунтов (для теста - 1000, в реальности сотни тысяч). События поступают в большом объёме непрерывно (для теста ограничим поток в 10к событий).
Обработка события занимает 1с. 

Реализовать фоновую обработку (sleep + лог "результатов") событий с сохранением очерёдности для каждого аккаунта. Веб-апи эмулировать консольным скриптом, генерирующим события для обработки в фоне.
События генерировать случайными блоками, содержащими последовательноси по 1-5 для каждого аккаунта.

## Идея решения

Для ускорения обработки поток событий распределяется в N очередей (используется RabbitMQ), каждую из который разбирает отдельный фоновый процесс.
Чтобы сохранить порядок обработки событий от одного клиента, необходимо такие события помещать в одну очередь (т.к. в рэббите очереди
по-умолчанию работают по принципу FIFO).

В данном решении реализован простой механизм маршрутизации событий: 
 - генератору должно быть известно количество клиентов K (им назначаем порядковые идентификаторы от 0 до К-1) и количество обработчиков N 
 (им также назначаем ключи от 0 до N-1)
 - при отправке события в очередь ему назначается ключ маршрутизации, равный остатку от деления идентификатора клиента на N. 
 Таким образом, события от одного клиента всегда попадают в одну очередь
 - в RabbitMQ используется direct exchange, который маршрутизирует событие в нужную очередь
 - обработчику при запуске передается его порядковый номер, чтобы он мог слушать соответствующую очередь
 
В реальном приложении с таким решением могут возникать определенные проблемы. Приведу их описание и возможные способы решения:
 - Неравномерное распределение нагрузки между обработчиками. В целом, если события от клиентов идут примерно в одинаковом количестве,
 то на больших числах распределение событий по очередям будет достаточно равномерным. Возможно, будет иметь смысл иначе строить ключ 
 в зависимости от идентификатора клиента. Также можно строить и использовать статистику количества обрабатываемых событий в каждой очереди
 для выбора ключа для новых клиентов.
 - Невозможность указания количества обработчиков на стороне генератора (либо потребность в динамическом измененении количества обработчиков).
 Тут могу предложить 2 идеи. Первая - использовать fanout exchange и определять "подходящие" события уже на стороне обработчика. В этом 
 случае возникает оверхэд на проверку и отклонение лишних событий. Второй вариант - насколько мне известно, через API рэббита можно получить
 метаданные эксчейнджа, в том числе все имеющиеся связи с очередями и их ключи. Эти ключи можно зарегистрировать на стороне генератора
 и использовать для роутинга событий.
 
 ## Технические моменты 
 
 Стек технологий: PHP7, RabbitMQ.
 
 Я сознательно не стал использовать какие-либо фреймворки, чтобы сосредоточиться на основной логике задачи. В реальном приложении, конечно,
 нужно использовать какой-нибудь контейнер зависимостей, корректную обработку и логирование ошибок, ENV-переменные для конфигурирования и т.п.
 
 Для запуска приложения нужно выполнить следующие шаги:
  - Установить зависимости:
  
  ```$ composer install```
  
  - Скопировать файл `config/config.php.dist` в `config/config.php` и прописать параметры подключения к RabbitMQ
  - Запустить генератор событий (требуется docker):
  
  ```$ bin/generate```  
  
  - Запустить обработчики событий (5 штук):
  
  ```$ bin/start-consumer```
  
  - Для остановки обработчиков используется команда 
  
  ```$ bin/stop-consumer```
  
  - Результат работы будет отображен в файле `logs/result.log` (каталог logs должен быть доступен для записи)